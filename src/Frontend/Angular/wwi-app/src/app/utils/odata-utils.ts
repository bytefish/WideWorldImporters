// Licensed under the MIT license. See LICENSE file in the project root for full license information.

import { HttpParams } from "@angular/common/http";
import { ClrDatagridStateInterface } from "@clr/angular";
import { ColumnFilter, ODataFilter } from "../models/filter";
import { HttpQueryParamType } from "../types/type-utils";
import { StringUtils } from "./string-utils";

/**
 * Utilities for working with OData Data Sources.
  */
export class ODataUtils {

    /**
     * Serializes a ``ClrDatagridStateInterface`` into an OData query with filters,
     * pagination and sort parameters. The result will also include a $count to get 
     * the total result set size.
     *
     * @param endpoint - OData-enabled endpoint we are querying.
     * @param state - The State of the DataGrid.
     * @param params - Addition $select and $expand parameters.
     * @returns OData query with Sorting, Filters and Pagination. 
     */
     public static asODataString(endpoint: string, state: ClrDatagridStateInterface, params: Partial<{ $select?: string, $expand?: string }>): string {

        const httpQueryParameters: HttpQueryParamType = {
            ...this.getSelectParameter(params.$select),
            ...this.getExpandParameter(params.$expand),
            ...this.toODataFilterStatements(state),
            ...this.getPaginationParameters(state),
            ...this.getSortParameters(state),
            ...{ "$count": true }
        };

        const httpParameters: HttpParams = new HttpParams().appendAll(httpQueryParameters);

        const queryString = httpParameters.toString();

        if (StringUtils.isNullOrWhitespace(queryString)) {
            return endpoint;
        }

        return `${endpoint}?${queryString}`;
    }

    /**
     * Returns the $select part of the OData query.
     *
     * @param select - The raw select string.
     * @returns The OData $select statement.
     */
    private static getSelectParameter(select?: string): HttpQueryParamType {

        if(!select) {
            return {};
        }

        return { "$select": select };
    }

     /**
     * Returns the $select part of the OData query.
     *
     * @param select - The raw select string.
     * @returns The OData $select statement.
     */
         private static getExpandParameter(expand?: string): HttpQueryParamType {
            if(!expand) {
                return {};
            }
    
            return { "$expand": expand };
        }

    /**
     * Serializes the filters of a ``ClrDatagridStateInterface`` into a ``HttpQueryParamType``, containing 
     * the ``$filter`` statements of an OData query.
     *
     * @param clrDataGridState - The state of the DataGrid.
     * @returns The OData $filter parameters.
     */
    private static toODataFilterStatements(clrDataGridState: ClrDatagridStateInterface): HttpQueryParamType {

        // Get all OData Filters from the Grid:
        const filters: ODataFilter[] = ODataUtils.castToODataFilters(clrDataGridState);

        // Serialize the to OData strings:
        const serializedFilters = ODataUtils.serializeAllFilters(filters);

        if (!serializedFilters) {
            return {};
        }

        return {
            "$filter": serializedFilters
        };
    }

    /**
     * Gets the ``ODataFilter[]`` from the ``ClrDatagridStateInterface#filter`` property.
     *
     * @param clrDataGridState - An array of ``ODataFilter``.
     * @returns The OData $filter value.
     */
    private static castToODataFilters(clrDataGridState: ClrDatagridStateInterface): ODataFilter[] {

        if (!clrDataGridState.filters) {
            return [];
        }

        return clrDataGridState.filters
            .filter(filter => (filter as ColumnFilter).toODataFilter) // Typescript has no "instanceof", so use some duck typing...
            .map(filterProvider => filterProvider.toODataFilter());
    }

    /**
     * Serializes all $filter statement generated by a given array of ``ODataFilter``.
     *
     * @param filters - An array of ``ODataFilter``.
     * @returns The OData $filter value.
     */
    private static serializeAllFilters(filters: ODataFilter[]): string {
        // Serialize the Filters:
        return filters
            // Format as OData string:
            .map((filter) => filter.toODataString())
            // There may be empty OData-strings:
            .filter(filter => !StringUtils.isNullOrWhitespace(filter))
            // Wrap it in parentheses, so concatenating filters doesn't lead to problems:
            .map((filter) => `(${filter})`)
            // Concat all Filters with AND:
            .join(' and ');
    }

    /**
     * Returns the optional OData $sort parameter.
     *
     * @param clrDataGridState - The state of the Data Grid.
     * @returns The OData $orderby statement.
     */
    private static getSortParameters(clrDataGridFilter: ClrDatagridStateInterface): HttpQueryParamType {

        if (!clrDataGridFilter.sort) {
            return {};
        }

        const by: string = clrDataGridFilter.sort.by.toString();

        if (StringUtils.isNullOrWhitespace(by)) {
            return {};
        }

        const result: HttpQueryParamType = {};

        if (clrDataGridFilter.sort.reverse) {
            result["$orderby"] = `${by} desc`;
        } else {
            result["$orderby"] = `${by}`;
        }

        return result;
    }

    /**
     * Gets the optional Pagination parameters ``$top`` and ``$skip``.
     *
     * @param clrDataGridState - The state of the Data Grid.
     * @returns The OData ``$top`` and ``$skip`` statements.
     */
    private static getPaginationParameters(clrDataGridFilter: ClrDatagridStateInterface): HttpQueryParamType {

        const page = clrDataGridFilter.page;

        if (!page) {
            return {};
        }

        const result: HttpQueryParamType = {};

        if (page.size) {
            result["$top"] = page.size;
        }

        if (page.current && page.size) {
            result["$skip"] = (page.current - 1) * page.size;
        }

        return result;
    }
}